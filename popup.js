// Import API key from secure config
// Make sure config.js is loaded before this script in manifest.json

// API calling functions for different providers
async function callTogetherAI(prompt, apiKey) {
  try {
    const response = await fetch(
      "https://api.together.xyz/v1/chat/completions",
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${apiKey}`,
        },
        body: JSON.stringify({
          model: "mistralai/Mixtral-8x7B-Instruct-v0.1",
          messages: [
            {
              role: "user",
              content: prompt,
            },
          ],
          temperature: 0.7,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Together AI Error:", errorData);
      throw new Error(
        `Together AI Error: ${response.status} - ${
          errorData.error?.message || "Unknown error"
        }`
      );
    }

    const data = await response.json();
    console.log("Together AI Response:", data);

    const text = data.choices?.[0]?.message?.content?.trim();
    if (!text) {
      console.error("No text found in Together AI response:", data);
      throw new Error("No content generated by Together AI");
    }

    return text;
  } catch (error) {
    console.error("Together AI call failed:", error);
    throw error;
  }
}

async function callGeminiAI(prompt, apiKey) {
  try {
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt,
                },
              ],
            },
          ],
          generationConfig: {
            temperature: 0.7,
            topK: 40,
            topP: 0.95,
            maxOutputTokens: 1024,
          },
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      console.error("Gemini API Error:", errorData);
      throw new Error(
        `Gemini API Error: ${response.status} - ${
          errorData.error?.message || "Unknown error"
        }`
      );
    }

    const data = await response.json();
    console.log("Gemini API Response:", data);

    if (data.error) {
      throw new Error(`Gemini API Error: ${data.error.message}`);
    }

    const text = data.candidates?.[0]?.content?.parts?.[0]?.text?.trim();
    if (!text) {
      console.error("No text found in Gemini response:", data);
      throw new Error("No content generated by Gemini");
    }

    return text;
  } catch (error) {
    console.error("Gemini API call failed:", error);
    throw error;
  }
}

// Enhanced problem analysis function
function analyzeProblem(problemText) {
  const analysis = {
    difficulty: "Medium", // Default
    topics: [],
    timeComplexity: "",
    hasExamples: false,
    constraints: "",
  };

  // Detect difficulty from common patterns
  const difficultyPatterns = [
    { pattern: /\b(easy|simple|basic|trivial)\b/i, level: "Easy" },
    { pattern: /\b(medium|moderate|intermediate)\b/i, level: "Medium" },
    { pattern: /\b(hard|difficult|challenging|complex)\b/i, level: "Hard" },
    { pattern: /\b(very hard|extremely hard|contest)\b/i, level: "Very Hard" },
  ];

  for (const { pattern, level } of difficultyPatterns) {
    if (pattern.test(problemText)) {
      analysis.difficulty = level;
      break;
    }
  }

  // Detect if it's from LeetCode and extract difficulty
  if (
    problemText.includes("Easy") ||
    problemText.includes("Medium") ||
    problemText.includes("Hard")
  ) {
    const diffMatch = problemText.match(/\b(Easy|Medium|Hard)\b/);
    if (diffMatch) analysis.difficulty = diffMatch[1];
  }

  // Detect common algorithm topics
  const topicPatterns = [
    { pattern: /\b(array|list|sort|search)\b/i, topic: "Arrays" },
    { pattern: /\b(tree|binary tree|bst)\b/i, topic: "Trees" },
    { pattern: /\b(graph|node|edge|dfs|bfs)\b/i, topic: "Graphs" },
    {
      pattern: /\b(dynamic programming|dp|memoization)\b/i,
      topic: "Dynamic Programming",
    },
    { pattern: /\b(string|substring|palindrome)\b/i, topic: "Strings" },
    { pattern: /\b(hash|map|dictionary)\b/i, topic: "Hash Tables" },
    { pattern: /\b(linked list|node|pointer)\b/i, topic: "Linked Lists" },
    { pattern: /\b(stack|queue|deque)\b/i, topic: "Stacks & Queues" },
    { pattern: /\b(recursive|recursion|backtrack)\b/i, topic: "Recursion" },
    {
      pattern: /\b(greedy|optimal|minimum|maximum)\b/i,
      topic: "Greedy Algorithms",
    },
  ];

  for (const { pattern, topic } of topicPatterns) {
    if (pattern.test(problemText)) {
      analysis.topics.push(topic);
    }
  }

  // Check for examples
  analysis.hasExamples = /example|input|output/i.test(problemText);

  // Extract constraints
  const constraintMatch = problemText.match(
    /constraint[s]?:?\s*(.+?)(?=\n\n|\n[A-Z]|$)/i
  );
  if (constraintMatch) {
    analysis.constraints = constraintMatch[1].trim();
  }

  return analysis;
}

// Enhanced AI prompt generator with pedagogical framework
function generateEnhancedPrompt(problemText, analysis) {
  const difficultyGuidance = {
    Easy: "Focus on fundamental concepts and intuitive approaches. Use gentle theoretical nudges.",
    Medium:
      "Balance theoretical foundations with algorithmic insights. Highlight key patterns and data structures.",
    Hard: "Emphasize deep theoretical understanding and advanced algorithmic techniques.",
    "Very Hard":
      "Provide sophisticated theoretical insights and complex pattern recognition. Focus on advanced optimization.",
  };

  const topicHints =
    analysis.topics.length > 0
      ? `Relevant topics may include: ${analysis.topics.join(", ")}. `
      : "";

  return `You are an expert computer science educator and competitive programming mentor. Analyze this ${
    analysis.difficulty
  } problem and provide exactly 3 educational hints following this pedagogical framework:

${difficultyGuidance[analysis.difficulty]}
${topicHints}

MANDATORY 3-PART STRUCTURE:

**1. Concept/Foundation Nudge üß†**
- Remind them of underlying theoretical concepts or core CS principles
- Connect to fundamental algorithms, data structures, or mathematical concepts they should know
- DON'T link it directly to the specific solution
- Trigger their existing knowledge base to make them feel empowered

**2. Problem-Specific Insight/Constraint Highlight üîç** 
- Guide them toward a specific observation about THIS problem's details or constraints
- Point out hidden properties, patterns, or simplifying factors
- Help them notice what makes this problem unique or what constraint is key
- More tailored than hint 1, but still not the full solution

**3. High-Level Strategy/Data Structure Suggestion üó∫Ô∏è**
- Suggest general approach or suitable algorithm/data structure category
- Provide solution framework without implementation details
- Help them choose the right tools for the job
- Move them from understanding to planning the solution structure

CRITICAL REQUIREMENTS:
- Each hint must be exactly ONE clear sentence
- NEVER reveal implementation steps or code logic
- Each hint should build educational value progressively
- Focus on teaching concepts, not just solving this problem
- Make them think and connect dots, don't hand them answers

EXAMPLES OF EXCELLENT PEDAGOGICAL HINTS:

For Number Theory Problem:
1. üß† "Consider how prime factorization fundamentally determines the number of divisors a number can have."
2. üîç "Notice that for divisibility by 25, the last two digits must follow a very specific pattern."  
3. üó∫Ô∏è "Think about whether you can precompute or mathematically derive the answer rather than simulating each step."

For Dynamic Programming Problem:
1. üß† "Recall how optimal substructure means the best solution to a problem contains optimal solutions to subproblems."
2. üîç "Observe that each decision you make affects future possibilities, and the state space might be smaller than it initially appears."
3. üó∫Ô∏è "Consider building up solutions incrementally where one dimension tracks your remaining budget or constraints."

For Graph/Tree Problem:
1. üß† "Think about how tree traversal algorithms systematically visit nodes to gather or propagate information."
2. üîç "Notice whether the problem requires information flowing from leaves to root, root to leaves, or both directions."
3. üó∫Ô∏è "Consider whether a single DFS/BFS pass can collect all needed information, or if you need multiple phases."

Problem to analyze:
${problemText}

IMPORTANT OUTPUT FORMAT:
Generate exactly 3 hints following this exact format:

1. [Your first hint here - concept/foundation nudge]
2. [Your second hint here - problem-specific insight] 
3. [Your third hint here - high-level strategy]

Each hint should be ONE clear sentence. Do not include any other text, explanations, or formatting.`;
}

// Auto-hint functionality - scan problem and get hints in one click
async function getHintsForProblem(problemText, selectedProvider, responseDiv) {
  if (!problemText || problemText.trim().length === 0) {
    responseDiv.textContent = "‚ùå No problem text found to analyze.";
    return;
  }

  // Get API keys from config
  const apiKeys = window.config?.apiKeys;
  const apiKey = apiKeys?.[selectedProvider];

  // Check if API key is configured
  if (!apiKey || apiKey === "your_api_key_here") {
    const providerName =
      selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Together AI";
    responseDiv.innerHTML = `
      <div style="text-align: center; padding: 12px; color: #dc3545;">
        <div style="font-size: 24px; margin-bottom: 8px;">üîë</div>
        <div style="font-weight: 600; margin-bottom: 8px;">API Key Not Configured</div>
        <div style="font-size: 13px; line-height: 1.4;">
          Please set up your ${providerName} API key in the config.js file.
        </div>
      </div>
    `;
    return;
  }

  const providerDisplayName =
    selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Mixtral AI";
  responseDiv.innerHTML = `‚è≥ Analyzing problem with ${providerDisplayName}...`;

  try {
    // Analyze the problem for better context
    const analysis = analyzeProblem(problemText);
    const enhancedPrompt = generateEnhancedPrompt(problemText, analysis);

    console.log("Problem Analysis:", analysis);
    console.log("Enhanced Prompt:", enhancedPrompt);
    console.log("Selected Provider:", selectedProvider);

    let reply;
    if (selectedProvider === "gemini") {
      reply = await callGeminiAI(enhancedPrompt, apiKey);
    } else {
      reply = await callTogetherAI(enhancedPrompt, apiKey);
    }

    console.log(`${providerDisplayName} Response:`, reply);

    if (!reply) {
      responseDiv.textContent = "‚ùå Could not generate hints.";
      return;
    }

    // Clear previous content
    responseDiv.innerHTML = "";

    // Enhanced hint parsing with debugging
    console.log("Raw AI Response:", reply);

    let hints = [];

    // Clean the response first - remove any intro text
    let cleanedReply = reply.trim();

    // Remove common intro phrases that might appear
    cleanedReply = cleanedReply.replace(/^.*?Here are.*?hints.*?:?\s*/is, "");
    cleanedReply = cleanedReply.replace(/^.*?three hints.*?:?\s*/is, "");
    cleanedReply = cleanedReply.replace(/^.*?following.*?format.*?:?\s*/is, "");
    cleanedReply = cleanedReply.replace(/^.*?OUTPUT FORMAT.*?:?\s*/is, "");
    cleanedReply = cleanedReply.replace(/^.*?IMPORTANT.*?:?\s*/is, "");

    console.log("Cleaned Reply:", cleanedReply);

    // Split by lines and find numbered items
    const lines = cleanedReply
      .split("\n")
      .map((line) => line.trim())
      .filter((line) => line.length > 0);

    console.log("All lines:", lines);

    // Extract hints that start with numbers
    for (const line of lines) {
      if (/^[1-3][\.\):\s]/.test(line)) {
        const hintText = line.replace(/^[1-3][\.\):\s]+/, "").trim();
        if (hintText.length > 5) {
          hints.push(hintText);
        }
      }
    }

    console.log("Numbered hints found:", hints);

    // If we didn't find 3 numbered hints, try to extract any meaningful sentences
    if (hints.length < 3) {
      console.log("Not enough numbered hints, trying sentence extraction...");

      // Look for sentences that might be hints (avoid intro text)
      const sentences = cleanedReply
        .split(/[.!?]+/)
        .map((s) => s.trim())
        .filter(
          (s) =>
            s.length > 20 &&
            s.length < 200 &&
            !s.toLowerCase().includes("hint") &&
            !s.toLowerCase().includes("format") &&
            !s.toLowerCase().includes("generate")
        );

      console.log("Extracted sentences:", sentences);

      // Take up to 3 sentences
      for (let i = 0; i < Math.min(3, sentences.length); i++) {
        if (hints.length < 3) {
          hints.push(sentences[i] + ".");
        }
      }
    }

    console.log("Extracted hints:", hints);

    // Ensure we have exactly 3 hints and keep them concise
    if (hints.length < 3) {
      // Split long hints or create generic ones
      if (hints.length === 1 && hints[0].length > 200) {
        const sentences = hints[0]
          .split(/[.!?]+/)
          .filter((s) => s.trim().length > 0);
        hints = [
          sentences.slice(0, Math.ceil(sentences.length / 3)).join(".") + ".",
          sentences
            .slice(
              Math.ceil(sentences.length / 3),
              2 * Math.ceil(sentences.length / 3)
            )
            .join(".") + ".",
          sentences.slice(2 * Math.ceil(sentences.length / 3)).join(".") + ".",
        ];
      } else {
        while (hints.length < 3) {
          hints.push("Think about this problem step by step.");
        }
      }
    } else if (hints.length > 3) {
      hints = hints.slice(0, 3);
    }

    // Clean and format hints properly
    hints = hints.map((hint, index) => {
      let cleanHint = hint.trim();

      // Remove numbering and common prefixes
      cleanHint = cleanHint.replace(/^\d+[\.\):\s]*/, "");
      cleanHint = cleanHint.replace(/^(üß†|üîç|üó∫Ô∏è)\s*/, "");
      cleanHint = cleanHint.replace(/^hint\s*\d*[\.\):\s]*/i, "");

      // Remove markdown formatting if present
      cleanHint = cleanHint.replace(/\*\*(.*?)\*\*/g, "$1");
      cleanHint = cleanHint.replace(/^\*\s*/, "");

      // Remove quotes if the entire hint is quoted
      if (cleanHint.startsWith('"') && cleanHint.endsWith('"')) {
        cleanHint = cleanHint.slice(1, -1);
      }

      cleanHint = cleanHint.trim();

      // Ensure it ends with proper punctuation
      if (cleanHint && !cleanHint.match(/[.!?]$/)) {
        cleanHint += ".";
      }

      console.log(`Hint ${index + 1} cleaned:`, cleanHint);
      return cleanHint;
    });

    // Filter out empty hints
    hints = hints.filter((hint) => hint && hint.length > 5);

    // Ensure we have exactly 3 hints
    if (hints.length === 0) {
      // Fallback: try to split the cleaned reply into sentences
      const sentences = cleanedReply
        .split(/[.!?]+/)
        .filter((s) => s.trim().length > 10);
      if (sentences.length >= 3) {
        hints = sentences.slice(0, 3).map((s) => s.trim() + ".");
      } else {
        responseDiv.innerHTML = `
          <div style="text-align: center; padding: 20px; color: #dc3545;">
            <div style="font-size: 24px; margin-bottom: 8px;">‚ö†Ô∏è</div>
            <div style="font-weight: 600; margin-bottom: 8px;">Could not parse hints</div>
            <div style="font-size: 13px; line-height: 1.4; margin-bottom: 12px;">
              The AI response format was unexpected. Here's the raw response:
            </div>
            <div style="background: #f8f9fa; padding: 10px; border-radius: 6px; font-size: 12px; text-align: left; max-height: 200px; overflow-y: auto;">
              ${reply.replace(/</g, "&lt;").replace(/>/g, "&gt;")}
            </div>
          </div>
        `;
        return;
      }
    }

    // Pad to exactly 3 hints if needed with different fallbacks
    const fallbackHints = [
      "Consider the fundamental concepts and data structures relevant to this type of problem.",
      "Look closely at the constraints and examples to identify key patterns or properties.",
      "Think about which algorithm or approach would be most efficient for the given constraints.",
    ];

    while (hints.length < 3) {
      const fallbackIndex = hints.length; // This ensures different hints for each position
      hints.push(
        fallbackHints[fallbackIndex] ||
          "Consider breaking this problem into smaller subproblems."
      );
    }

    // Ensure exactly 3 hints
    hints = hints.slice(0, 3);

    console.log("Final hints to display:", hints);

    // Create buttons for each hint
    hints.forEach((hintText, index) => {
      const wrapper = document.createElement("div");
      wrapper.style.marginTop = "10px";

      // Hint title
      const title = document.createElement("div");
      title.textContent = `üîπ Hint ${index + 1}`;
      title.style.fontWeight = "700";
      title.style.fontSize = "15px";
      title.style.marginBottom = "8px";
      title.style.color = "#4f46e5";
      title.style.letterSpacing = "0.5px";

      // Toggle button
      const toggleBtn = document.createElement("button");
      toggleBtn.textContent = `üëÅÔ∏è Show Hint`;
      toggleBtn.style.padding = "12px 16px";
      toggleBtn.style.width = "100%";
      toggleBtn.style.background =
        "linear-gradient(135deg, #4f46e5 0%, #6366f1 100%)";
      toggleBtn.style.color = "white";
      toggleBtn.style.fontWeight = "600";
      toggleBtn.style.border = "none";
      toggleBtn.style.borderRadius = "8px";
      toggleBtn.style.cursor = "pointer";
      toggleBtn.style.transition = "all 0.3s ease";
      toggleBtn.style.fontSize = "14px";
      toggleBtn.style.boxShadow = "0 2px 8px rgba(79, 70, 229, 0.2)";

      // Add hover effects
      toggleBtn.addEventListener("mouseenter", () => {
        toggleBtn.style.background =
          "linear-gradient(135deg, #3730a3 0%, #4f46e5 100%)";
        toggleBtn.style.transform = "translateY(-1px)";
        toggleBtn.style.boxShadow = "0 4px 12px rgba(79, 70, 229, 0.3)";
      });

      toggleBtn.addEventListener("mouseleave", () => {
        toggleBtn.style.background =
          "linear-gradient(135deg, #4f46e5 0%, #6366f1 100%)";
        toggleBtn.style.transform = "translateY(0)";
        toggleBtn.style.boxShadow = "0 2px 8px rgba(79, 70, 229, 0.2)";
      });

      toggleBtn.addEventListener("mousedown", () => {
        toggleBtn.style.transform = "translateY(0)";
        toggleBtn.style.boxShadow = "0 2px 4px rgba(79, 70, 229, 0.2)";
      });

      // Hidden hint text (with enhanced styling)
      const hintPara = document.createElement("div");
      hintPara.style.marginTop = "8px";
      hintPara.style.padding = "12px 14px";
      hintPara.style.background =
        "linear-gradient(135deg, #f8f9fa 0%, #ffffff 100%)";
      hintPara.style.border = "1px solid #dee2e6";
      hintPara.style.borderLeft = "4px solid #4f46e5";
      hintPara.style.borderRadius = "8px";
      hintPara.style.maxHeight = "0px";
      hintPara.style.overflow = "hidden";
      hintPara.style.transition = "max-height 0.4s ease, padding 0.2s ease";
      hintPara.style.fontSize = "14px";
      hintPara.style.fontWeight = "600"; // Makes text bolder
      hintPara.style.lineHeight = "1.6"; // Better readability
      hintPara.style.color = "#2d3748"; // Darker, more readable color
      hintPara.style.boxShadow = "0 2px 4px rgba(0, 0, 0, 0.06)";
      hintPara.style.paddingTop = "0px";
      hintPara.style.paddingBottom = "0px";
      hintPara.textContent = hintText;

      // Toggle animation
      toggleBtn.addEventListener("click", () => {
        const isOpen = hintPara.style.maxHeight !== "0px";
        if (isOpen) {
          hintPara.style.maxHeight = "0px";
          hintPara.style.paddingTop = "0px";
          hintPara.style.paddingBottom = "0px";
          toggleBtn.textContent = "üëÅÔ∏è Show Hint";
        } else {
          hintPara.style.maxHeight = "250px"; // Increased for better text display
          hintPara.style.paddingTop = "12px";
          hintPara.style.paddingBottom = "12px";
          toggleBtn.textContent = "üëÅÔ∏è Hide Hint";
        }
      });

      // Separator line
      const separator = document.createElement("hr");
      separator.style.margin = "20px 0";
      separator.style.border = "none";
      separator.style.borderTop = "2px solid #f1f3f5";
      separator.style.borderRadius = "1px";

      // Append all elements
      wrapper.appendChild(title);
      wrapper.appendChild(toggleBtn);
      wrapper.appendChild(hintPara);
      wrapper.appendChild(separator);
      responseDiv.appendChild(wrapper);
    });
  } catch (err) {
    console.error("API Error:", err);
    const providerName =
      selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Together AI";

    // Show more specific error messages
    if (err.message.includes("API Error:")) {
      responseDiv.textContent = `‚ùå ${providerName} Error: ${err.message}`;
    } else if (err.message.includes("fetch")) {
      responseDiv.textContent = `‚ùå Network Error: Unable to connect to ${providerName}`;
    } else {
      responseDiv.textContent = `‚ùå ${providerName} Error: ${err.message}`;
    }
  }
}

// Auto-hint button event listener
document.getElementById("autoHintBtn").addEventListener("click", async () => {
  const responseDiv = document.getElementById("response");
  const selectedProvider = document.getElementById("providerSelect").value;

  responseDiv.innerHTML = "üîç Scanning for problem...";

  chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
    const currentUrl = tabs[0].url;
    console.log("Current URL:", currentUrl);

    // Check if URL matches our patterns
    const supportedPatterns = [
      /^https?:\/\/(www\.)?leetcode\.com\//,
      /^https?:\/\/(www\.)?codeforces\.com\//,
      /^https?:\/\/(www\.)?codechef\.com\//,
    ];

    const isSupported = supportedPatterns.some((pattern) =>
      pattern.test(currentUrl)
    );

    if (!isSupported) {
      responseDiv.innerHTML = `‚ùå Not a supported coding platform`;
      return;
    }

    // Check if user is on LeetCode homepage or problems list (not a specific problem)
    if (currentUrl.includes("leetcode.com")) {
      const isHomepage = /^https?:\/\/(www\.)?leetcode\.com\/?$/.test(
        currentUrl
      );
      const isProblemsPage =
        /^https?:\/\/(www\.)?leetcode\.com\/problems\/?$/.test(currentUrl);
      const isProblemsListPage =
        /^https?:\/\/(www\.)?leetcode\.com\/problemset\//.test(currentUrl);

      if (isHomepage || isProblemsPage || isProblemsListPage) {
        responseDiv.innerHTML = `
          <div style="text-align: center; padding: 12px;">
            <div style="font-size: 24px; margin-bottom: 8px;">üéØ</div>
            <div style="font-weight: 600; margin-bottom: 8px;">Navigate to a Problem</div>
            <div style="font-size: 13px; color: #666; line-height: 1.4;">
              Please go to a specific LeetCode problem page first, then click the button to get instant hints.
            </div>
            <div style="margin-top: 10px; font-size: 12px; color: #999;">
              Example: leetcode.com/problems/two-sum/
            </div>
          </div>
        `;
        return;
      }
    }

    chrome.tabs.sendMessage(tabs[0].id, { action: "rescan" }, (response) => {
      if (chrome.runtime.lastError) {
        responseDiv.innerHTML =
          "‚ö†Ô∏è Please try again (extension may be loading)";
        return;
      }

      if (response && response.success && response.problemText) {
        // Auto-generate hints for the extracted problem
        getHintsForProblem(response.problemText, selectedProvider, responseDiv);
      } else {
        responseDiv.innerHTML = "‚ö†Ô∏è Could not find problem on this page";
      }
    });
  });
});

// Format AI analysis results into structured sections
function formatAnalysisResults(rawAnalysis) {
  const sections = [
    {
      emoji: "üîç",
      title: "COMPLEXITY ANALYSIS",
      color: "#e53e3e",
      keywords: ["complexity analysis", "time complexity", "space complexity"],
    },
    {
      emoji: "‚ö°",
      title: "PERFORMANCE ASSESSMENT",
      color: "#d69e2e",
      keywords: ["performance assessment", "performance"],
    },
    {
      emoji: "üõ†Ô∏è",
      title: "CODE QUALITY",
      color: "#3182ce",
      keywords: ["code quality", "readability", "best practices"],
    },
    {
      emoji: "üöÄ",
      title: "OPTIMIZATION OPPORTUNITIES",
      color: "#805ad5",
      keywords: ["optimization", "improvements"],
    },
    {
      emoji: "üéØ",
      title: "ALTERNATIVE APPROACHES",
      color: "#38a169",
      keywords: ["alternative", "approaches", "different"],
    },
    {
      emoji: "üí°",
      title: "KEY INSIGHTS",
      color: "#dd6b20",
      keywords: ["insights", "takeaways", "learning"],
    },
  ];

  let formattedHtml = `
    <div style="background: linear-gradient(135deg, #f7fafc 0%, #edf2f7 100%); border-radius: 12px; padding: 16px; margin-bottom: 16px;">
      <div style="display: flex; align-items: center; margin-bottom: 16px;">
        <span style="font-size: 22px; margin-right: 10px;">ü§ñ</span>
        <h3 style="margin: 0; font-size: 18px; font-weight: 700; color: #2d3748;">AI Code Analysis Results</h3>
      </div>
    </div>
  `;

  // Parse each section
  let foundSections = 0;
  for (const section of sections) {
    const sectionContent = extractSection(rawAnalysis, section);
    if (sectionContent) {
      formattedHtml += createSectionHtml(section, sectionContent);
      foundSections++;
    }
  }

  // Fallback: if no sections were found, display the raw analysis in a nice format
  if (foundSections === 0) {
    formattedHtml += `
      <div style="background: white; border-radius: 8px; border-left: 4px solid #16a085; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.06);">
        <div style="padding: 16px;">
          <div style="display: flex; align-items: center; margin-bottom: 12px;">
            <span style="font-size: 20px; margin-right: 10px;">üìù</span>
            <h4 style="margin: 0; font-size: 16px; font-weight: 700; color: #16a085;">Analysis Results</h4>
          </div>
          <div style="color: #4a5568; line-height: 1.6; font-size: 14px;">
            ${rawAnalysis
              .replace(
                /\*\*(.*?)\*\*/g,
                '<strong style="color: #2d3748;">$1</strong>'
              )
              .replace(/\n/g, "<br>")}
          </div>
        </div>
      </div>
    `;
  }

  return formattedHtml;
}

function extractSection(text, section) {
  // Try to find the section by looking for the emoji and title
  const patterns = [
    new RegExp(
      `${section.emoji}\\s*\\*\\*${
        section.title
      }\\*\\*:?\\s*([\\s\\S]*?)(?=${sections.map((s) => s.emoji).join("|")}|$)`,
      "i"
    ),
    new RegExp(
      `${section.emoji}\\s*${section.title}:?\\s*([\\s\\S]*?)(?=${sections
        .map((s) => s.emoji)
        .join("|")}|$)`,
      "i"
    ),
    new RegExp(
      `\\*\\*${section.title}\\*\\*:?\\s*([\\s\\S]*?)(?=\\*\\*[A-Z\\s]+\\*\\*|$)`,
      "i"
    ),
  ];

  for (const pattern of patterns) {
    const match = text.match(pattern);
    if (match && match[1]) {
      return match[1].trim();
    }
  }

  // Fallback: search by keywords
  const lines = text.split("\n");
  let sectionStart = -1;
  let sectionEnd = -1;

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].toLowerCase();
    if (section.keywords.some((keyword) => line.includes(keyword))) {
      sectionStart = i;
      break;
    }
  }

  if (sectionStart !== -1) {
    // Find the end of this section
    for (let i = sectionStart + 1; i < lines.length; i++) {
      const line = lines[i].toLowerCase();
      if (
        sections.some((s) =>
          s.keywords.some((keyword) => line.includes(keyword))
        ) &&
        !section.keywords.some((keyword) => line.includes(keyword))
      ) {
        sectionEnd = i;
        break;
      }
    }

    if (sectionEnd === -1) sectionEnd = lines.length;
    return lines
      .slice(sectionStart + 1, sectionEnd)
      .join("\n")
      .trim();
  }

  return null;
}

function createSectionHtml(section, content) {
  // Clean up the content
  let cleanContent = content
    .replace(/^\*\*.*?\*\*:?\s*/i, "") // Remove repeated headers
    .replace(/\*\*(.*?)\*\*/g, '<strong style="color: #2d3748;">$1</strong>') // Bold text
    .replace(/^-\s+/gm, "‚Ä¢ ") // Convert dashes to bullets
    .trim();

  return `
    <div style="background: white; border-radius: 8px; border-left: 4px solid ${
      section.color
    }; margin-bottom: 16px; box-shadow: 0 2px 4px rgba(0,0,0,0.06);">
      <div style="padding: 16px;">
        <div style="display: flex; align-items: center; margin-bottom: 12px;">
          <span style="font-size: 20px; margin-right: 10px;">${
            section.emoji
          }</span>
          <h4 style="margin: 0; font-size: 16px; font-weight: 700; color: ${
            section.color
          };">${section.title}</h4>
        </div>
        <div style="color: #4a5568; line-height: 1.6; font-size: 14px;">
          ${cleanContent.replace(/\n/g, "<br>")}
        </div>
      </div>
    </div>
  `;
}

// Define sections array for the extraction function
const sections = [
  {
    emoji: "üîç",
    title: "COMPLEXITY ANALYSIS",
    color: "#e53e3e",
    keywords: ["complexity analysis", "time complexity", "space complexity"],
  },
  {
    emoji: "‚ö°",
    title: "PERFORMANCE ASSESSMENT",
    color: "#d69e2e",
    keywords: ["performance assessment", "performance"],
  },
  {
    emoji: "üõ†Ô∏è",
    title: "CODE QUALITY",
    color: "#3182ce",
    keywords: ["code quality", "readability", "best practices"],
  },
  {
    emoji: "üöÄ",
    title: "OPTIMIZATION OPPORTUNITIES",
    color: "#805ad5",
    keywords: ["optimization", "improvements"],
  },
  {
    emoji: "üéØ",
    title: "ALTERNATIVE APPROACHES",
    color: "#38a169",
    keywords: ["alternative", "approaches", "different"],
  },
  {
    emoji: "üí°",
    title: "KEY INSIGHTS",
    color: "#dd6b20",
    keywords: ["insights", "takeaways", "learning"],
  },
];

// AI Code Analysis functionality
async function analyzeCode(code, selectedProvider, resultDiv) {
  if (!code || code.trim().length === 0) {
    resultDiv.textContent = "‚ùå Please paste your code first.";
    resultDiv.style.display = "block";
    return;
  }

  // Get API keys from config
  const apiKeys = window.config?.apiKeys;
  const apiKey = apiKeys?.[selectedProvider];

  // Check if API key is configured
  if (!apiKey || apiKey === "your_api_key_here") {
    const providerName =
      selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Together AI";
    resultDiv.innerHTML = `
      <div style="text-align: center; padding: 12px; color: #dc3545;">
        <div style="font-size: 24px; margin-bottom: 8px;">üîë</div>
        <div style="font-weight: 600; margin-bottom: 8px;">API Key Not Configured</div>
        <div style="font-size: 13px; line-height: 1.4;">
          Please set up your ${providerName} API key in the config.js file.
        </div>
      </div>
    `;
    resultDiv.style.display = "block";
    return;
  }

  const providerDisplayName =
    selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Mixtral AI";

  resultDiv.innerHTML = `‚è≥ Analyzing your code with ${providerDisplayName}...`;
  resultDiv.style.display = "block";

  try {
    const analysisPrompt = `You are an expert code reviewer and algorithm analyst. Analyze this code thoroughly and provide detailed feedback.

CODE TO ANALYZE:
${code}

PROVIDE ANALYSIS IN THIS EXACT FORMAT:

üîç **COMPLEXITY ANALYSIS:**
- Time Complexity: O(?)
- Space Complexity: O(?)
- Explanation: [Brief explanation of why]

‚ö° **PERFORMANCE ASSESSMENT:**
[Rate performance: Optimal/Good/Average/Poor and explain why]

üõ†Ô∏è **CODE QUALITY:**
- Readability: [Good/Average/Poor]
- Best Practices: [What's good/what could improve]
- Edge Cases: [Are they handled?]

üöÄ **OPTIMIZATION OPPORTUNITIES:**
[If any optimizations possible, suggest specific improvements with complexity benefits]

üéØ **ALTERNATIVE APPROACHES:**
[Suggest 1-2 different algorithmic approaches if applicable]

üí° **KEY INSIGHTS:**
[Main takeaways and learning points]

Be specific, educational, and constructive. Focus on helping the developer learn and improve.`;

    console.log("Code Analysis Prompt:", analysisPrompt);

    let reply;
    if (selectedProvider === "gemini") {
      reply = await callGeminiAI(analysisPrompt, apiKey);
    } else {
      reply = await callTogetherAI(analysisPrompt, apiKey);
    }

    console.log(`${providerDisplayName} Code Analysis:`, reply);

    if (!reply) {
      resultDiv.textContent = "‚ùå Could not analyze code.";
      return;
    }

    // Parse and format the analysis properly
    const formattedAnalysis = formatAnalysisResults(reply);
    resultDiv.innerHTML = formattedAnalysis;
  } catch (err) {
    console.error("Code Analysis Error:", err);
    const providerName =
      selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Together AI";

    if (err.message.includes("API Error:")) {
      resultDiv.textContent = `‚ùå ${providerName} Error: ${err.message}`;
    } else if (err.message.includes("fetch")) {
      resultDiv.textContent = `‚ùå Network Error: Unable to connect to ${providerName}`;
    } else {
      resultDiv.textContent = `‚ùå ${providerName} Error: ${err.message}`;
    }
  }
}

// Note: Old scan button and sendProblem message handling removed for streamlined auto-hint workflow

// Create visual display for problem analysis
function createAnalysisDisplay(analysis) {
  const difficultyColors = {
    Easy: "#10b981",
    Medium: "#f59e0b",
    Hard: "#ef4444",
    "Very Hard": "#7c3aed",
  };

  const difficultyColor = difficultyColors[analysis.difficulty] || "#6b7280";

  let html = `
    <div style="margin-top: 10px; padding: 8px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid ${difficultyColor};">
      <div style="font-size: 12px; font-weight: 600; color: ${difficultyColor};">
        üìä ${analysis.difficulty} Problem
      </div>
  `;

  if (analysis.topics.length > 0) {
    html += `
      <div style="margin-top: 4px; font-size: 11px; color: #666;">
        üè∑Ô∏è Topics: ${analysis.topics.slice(0, 3).join(", ")}${
      analysis.topics.length > 3 ? "..." : ""
    }
      </div>
    `;
  }

  html += `</div>`;
  return html;
}

// Auto-analyze code button event listener - works like the hint button
document
  .getElementById("autoAnalyzeBtn")
  .addEventListener("click", async () => {
    const analysisResult = document.getElementById("analysisResult");
    const selectedProvider = document.getElementById("providerSelect").value;
    const autoAnalyzeBtn = document.getElementById("autoAnalyzeBtn");

    analysisResult.innerHTML = "üîç Scanning for code...";

    // Disable button during analysis
    autoAnalyzeBtn.disabled = true;
    autoAnalyzeBtn.textContent = "üîÑ Analyzing...";

    chrome.tabs.query({ active: true, currentWindow: true }, async (tabs) => {
      const currentUrl = tabs[0].url;
      console.log("Current URL:", currentUrl);

      // Check if URL matches our patterns
      const supportedPatterns = [
        /^https?:\/\/(www\.)?leetcode\.com\//,
        /^https?:\/\/(www\.)?codeforces\.com\//,
        /^https?:\/\/(www\.)?codechef\.com\//,
      ];

      const isSupported = supportedPatterns.some((pattern) =>
        pattern.test(currentUrl)
      );

      if (!isSupported) {
        analysisResult.innerHTML = `‚ùå Not a supported coding platform`;
        return;
      }

      // Check if user is on LeetCode homepage or problems list (not a specific problem)
      if (currentUrl.includes("leetcode.com")) {
        const isHomepage = /^https?:\/\/(www\.)?leetcode\.com\/?$/.test(
          currentUrl
        );
        const isProblemsPage =
          /^https?:\/\/(www\.)?leetcode\.com\/problems\/?$/.test(currentUrl);
        const isProblemsListPage =
          /^https?:\/\/(www\.)?leetcode\.com\/problemset\//.test(currentUrl);

        if (isHomepage || isProblemsPage || isProblemsListPage) {
          analysisResult.innerHTML = `
            <div style="text-align: center; padding: 12px;">
              <div style="font-size: 24px; margin-bottom: 8px;">üéØ</div>
              <div style="font-weight: 600; margin-bottom: 8px;">Navigate to a Problem</div>
              <div style="font-size: 13px; color: #666; line-height: 1.4;">
                Please go to a specific LeetCode problem page with your code, then click the button to get instant analysis.
              </div>
              <div style="margin-top: 10px; font-size: 12px; color: #999;">
                Example: leetcode.com/problems/two-sum/
              </div>
            </div>
          `;
          return;
        }
      }

      chrome.tabs.sendMessage(
        tabs[0].id,
        { action: "extractCode" },
        (response) => {
          if (chrome.runtime.lastError) {
            analysisResult.innerHTML =
              "‚ö†Ô∏è Please reload the page and try again (extension may be loading)";
            // Re-enable button on error
            autoAnalyzeBtn.disabled = false;
            autoAnalyzeBtn.textContent = "ü§ñ Auto-Analyze Code from Editor";
            return;
          }

          if (response && response.success && response.code) {
            analysisResult.innerHTML = `‚è≥ Code detected! Analyzing with AI...`;

            // Auto-analyze the extracted code (handle async properly)
            analyzeCodeFromExtraction(
              response.code,
              selectedProvider,
              analysisResult
            )
              .then(() => {
                console.log("‚úÖ Analysis completed successfully");
                // Re-enable button after analysis completes
                autoAnalyzeBtn.disabled = false;
                autoAnalyzeBtn.textContent = "ü§ñ Auto-Analyze Code from Editor";
              })
              .catch((error) => {
                console.error("‚ùå Analysis promise rejected:", error);
                analysisResult.innerHTML =
                  "‚ùå Analysis failed. Please try again.";
                // Re-enable button on error
                autoAnalyzeBtn.disabled = false;
                autoAnalyzeBtn.textContent = "ü§ñ Auto-Analyze Code from Editor";
              });
          } else {
            analysisResult.innerHTML = `
            <div style="text-align: center; padding: 12px; color: #dc3545;">
              <div style="font-size: 24px; margin-bottom: 8px;">üìù</div>
              <div style="font-weight: 600; margin-bottom: 8px;">No Code Found</div>
              <div style="font-size: 13px; line-height: 1.4;">
                Please make sure you have code in the LeetCode editor, then try again.
              </div>
            </div>
          `;
            // Re-enable button on error
            autoAnalyzeBtn.disabled = false;
            autoAnalyzeBtn.textContent = "ü§ñ Auto-Analyze Code from Editor";
          }
        }
      );
    });
  });

// Helper function for auto-analysis (like the hint analysis)
async function analyzeCodeFromExtraction(code, selectedProvider, resultDiv) {
  if (!code || code.trim().length === 0) {
    resultDiv.textContent = "‚ùå No code found to analyze.";
    return;
  }

  // Get API keys from config
  const apiKeys = window.config?.apiKeys;
  const apiKey = apiKeys?.[selectedProvider];

  // Check if API key is configured
  if (!apiKey || apiKey === "your_api_key_here") {
    const providerName =
      selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Together AI";
    resultDiv.innerHTML = `
      <div style="text-align: center; padding: 12px; color: #dc3545;">
        <div style="font-size: 24px; margin-bottom: 8px;">üîë</div>
        <div style="font-weight: 600; margin-bottom: 8px;">API Key Not Configured</div>
        <div style="font-size: 13px; line-height: 1.4;">
          Please set up your ${providerName} API key in the config.js file.
        </div>
      </div>
    `;
    return;
  }

  const providerDisplayName =
    selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Mixtral AI";

  resultDiv.innerHTML = `‚è≥ Analyzing your code with ${providerDisplayName}...`;

  try {
    const analysisPrompt = `You are an expert code reviewer and algorithm analyst. Analyze this code thoroughly and provide detailed feedback.

CODE TO ANALYZE:
${code}

PROVIDE ANALYSIS IN THIS EXACT FORMAT:

üîç **COMPLEXITY ANALYSIS:**
- Time Complexity: O(?)
- Space Complexity: O(?)
- Explanation: [Brief explanation of why]

‚ö° **PERFORMANCE ASSESSMENT:**
[Rate performance: Optimal/Good/Average/Poor and explain why]

üõ†Ô∏è **CODE QUALITY:**
- Readability: [Good/Average/Poor]
- Best Practices: [What's good/what could improve]
- Edge Cases: [Are they handled?]

üöÄ **OPTIMIZATION OPPORTUNITIES:**
[If any optimizations possible, suggest specific improvements with complexity benefits]

üéØ **ALTERNATIVE APPROACHES:**
[Suggest 1-2 different algorithmic approaches if applicable]

üí° **KEY INSIGHTS:**
[Main takeaways and learning points]

Be specific, educational, and constructive. Focus on helping the developer learn and improve.`;

    let reply;
    if (selectedProvider === "gemini") {
      reply = await callGeminiAI(analysisPrompt, apiKey);
    } else {
      reply = await callTogetherAI(analysisPrompt, apiKey);
    }

    if (!reply) {
      resultDiv.textContent = "‚ùå Could not analyze code.";
      return;
    }

    // Create clean, readable analysis display without complex formatting

    // Simple, clean formatting that removes special characters and grey blocks
    const cleanText = reply
      .replace(/\*\*(.*?)\*\*/g, "$1") // Remove bold markdown
      .replace(/```[\s\S]*?```/g, "") // Remove all code blocks completely
      .replace(/[^\w\s\-.,!?():/\n\r]/g, " ") // Remove special characters except basic punctuation
      .replace(/\s+/g, " ") // Normalize whitespace
      .trim();

    // Split into sections and format simply
    const sections = [
      { title: "Complexity Analysis", emoji: "üîç", color: "#dc2626" },
      { title: "Performance Assessment", emoji: "‚ö°", color: "#f59e0b" },
      { title: "Code Quality", emoji: "üõ†Ô∏è", color: "#3b82f6" },
      { title: "Optimization Opportunities", emoji: "üöÄ", color: "#8b5cf6" },
      { title: "Alternative Approaches", emoji: "üéØ", color: "#22c55e" },
      { title: "Key Insights", emoji: "üí°", color: "#f59e0b" },
    ];

    // Parse sections from the clean text
    let formattedContent = "";
    let remainingText = cleanText;

    sections.forEach((section, index) => {
      // Look for section in text
      const patterns = [
        new RegExp(
          `${
            section.emoji
          }\\s*${section.title.toUpperCase()}[:\\s]*([\\s\\S]*?)(?=${sections
            .slice(index + 1)
            .map((s) => s.emoji)
            .join("|")}|$)`,
          "i"
        ),
        new RegExp(
          `${section.title.toUpperCase()}[:\\s]*([\\s\\S]*?)(?=${sections
            .slice(index + 1)
            .map((s) => s.title.toUpperCase())
            .join("|")}|$)`,
          "i"
        ),
      ];

      for (const pattern of patterns) {
        const match = remainingText.match(pattern);
        if (match && match[1] && match[1].trim().length > 10) {
          const content = match[1]
            .trim()
            .replace(/^[-‚Ä¢]\s*/gm, "") // Remove bullet points
            .replace(/\n\s*\n/g, "\n") // Remove extra line breaks
            .trim();

          if (content.length > 10) {
            formattedContent += `
              <div style="background: white; border-left: 4px solid ${
                section.color
              }; padding: 16px; margin: 12px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                <h4 style="color: ${
                  section.color
                }; margin: 0 0 8px 0; font-size: 16px; font-weight: 600;">
                  ${section.emoji} ${section.title}
                </h4>
                <div style="color: #374151; line-height: 1.6; font-size: 14px;">
                  ${content.replace(/\n/g, "<br>")}
                </div>
              </div>
            `;
            break;
          }
        }
      }
    });

    // Fallback: if no sections found, just show clean text
    if (!formattedContent.trim()) {
      formattedContent = `
        <div style="background: white; border-left: 4px solid #6b7280; padding: 16px; margin: 12px 0; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
          <div style="color: #374151; line-height: 1.6; font-size: 14px;">
            ${cleanText.replace(/\n/g, "<br>")}
          </div>
        </div>
      `;
    }

    const simpleAnalysis = `
      <div style="background: white; border-radius: 12px; padding: 20px; margin: 12px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1); border: 1px solid #e5e7eb;">
        <div style="display: flex; align-items: center; margin-bottom: 16px; padding-bottom: 12px; border-bottom: 1px solid #e5e7eb;">
          <div style="background: #3b82f6; width: 40px; height: 40px; border-radius: 8px; display: flex; align-items: center; justify-content: center; margin-right: 12px;">
            <span style="font-size: 20px;">ü§ñ</span>
          </div>
          <div>
            <h3 style="margin: 0; font-size: 18px; font-weight: 600; color: #111827;">AI Code Analysis</h3>
            <p style="margin: 2px 0 0 0; font-size: 13px; color: #6b7280;">Clean and readable results</p>
          </div>
        </div>
        <div style="font-family: 'Segoe UI', -apple-system, BlinkMacSystemFont, sans-serif;">
          ${formattedContent}
        </div>
      </div>
    `;

    resultDiv.innerHTML = simpleAnalysis;

    // Apply professional styling to make it visible and beautiful
    resultDiv.style.cssText = `
      display: block !important;
      visibility: visible !important;
      opacity: 1 !important;
      height: auto !important;
      max-height: 400px !important;
      overflow-y: auto !important;
      margin: 16px 0 !important;
      padding: 0 !important;
      background: transparent !important;
      position: relative !important;
      width: 100% !important;
    `;
  } catch (err) {
    console.error("Code Analysis Error:", err);
    const providerName =
      selectedProvider === "gemini" ? "Gemini 2.0 Flash" : "Together AI";

    if (err.message.includes("API Error:")) {
      resultDiv.textContent = `‚ùå ${providerName} Error: ${err.message}`;
    } else if (err.message.includes("fetch")) {
      resultDiv.textContent = `‚ùå Network Error: Unable to connect to ${providerName}`;
    } else {
      resultDiv.textContent = `‚ùå ${providerName} Error: ${err.message}`;
    }
  }
}

// Initialize the provider selector with default value from config
document.addEventListener("DOMContentLoaded", () => {
  const providerSelect = document.getElementById("providerSelect");
  const defaultProvider = window.config?.defaultProvider || "gemini";

  if (providerSelect) {
    providerSelect.value = defaultProvider;
    console.log("Initialized with provider:", defaultProvider);
  }
});
